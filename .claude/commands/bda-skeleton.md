# /bda-skeleton - コードスケルトン生成

Implementation InventoryからDDD準拠のコードスケルトンを自動生成します。

## 引数

```
/bda-skeleton {context_name}
/bda-skeleton {context_name} --layer {domain|application|infrastructure|interfaces}
/bda-skeleton {context_name} --backend-only
/bda-skeleton {context_name} --frontend-only
```

## 前提条件

- `_docs/inventory/{context}_inventory.md` が存在すること
- `design/guidelines/tech_stack.yaml` で技術スタックが定義されていること

## 生成されるディレクトリ構造

### Backend (Python/FastAPI)

```
backend/src/
├── domain/{context}/
│   ├── __init__.py
│   ├── entity.py           # Aggregate
│   ├── value_objects.py    # Value Objects, Enums
│   ├── events.py           # Domain Events
│   ├── repository.py       # Repository Interface (ABC)
│   └── services.py         # Domain Services (if any)
├── application/{context}/
│   ├── __init__.py
│   ├── {usecase_name}.py   # Each UseCase
│   ├── dto.py              # DTOs
│   └── queries/
│       └── {query_name}.py # Each Query
├── infrastructure/{context}/
│   ├── __init__.py
│   └── repository_impl.py  # Repository Implementation
└── interfaces/api/
    └── {context}_controller.py  # FastAPI Router
```

### Frontend (Next.js/TypeScript)

```
frontend/src/
├── app/{feature}/
│   └── page.tsx            # Page Component
├── hooks/
│   └── use{Feature}.ts     # ViewModel Hook
└── components/{feature}/
    └── {Component}.tsx     # UI Components
```

---

## スケルトンテンプレート

### Domain Layer

#### entity.py (Aggregate)

```python
"""
{ContextName} Domain - {AggregateName} Aggregate
Generated by /bda-skeleton
"""
from dataclasses import dataclass, field
from typing import Optional
from datetime import datetime

from .value_objects import {AggregateName}Id
from .events import {EventName}


@dataclass
class {AggregateName}:
    """
    {AggregateName} Aggregate Root

    Invariants:
        - TODO: Define business rules
    """
    id: {AggregateName}Id
    # TODO: Add properties from domain.yaml
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: Optional[datetime] = None

    def {behavior_name}(self) -> {EventName}:
        """
        {behavior_description}

        Returns:
            {EventName}: Domain event to be published

        Raises:
            ValueError: If invariant is violated
        """
        # TODO: Implement business logic
        raise NotImplementedError()
```

#### value_objects.py

```python
"""
{ContextName} Domain - Value Objects
Generated by /bda-skeleton
"""
from dataclasses import dataclass
from enum import Enum
from typing import NewType


# ID Value Objects
{AggregateName}Id = NewType("{AggregateName}Id", int)


# Enums
class {EnumName}(str, Enum):
    """TODO: Add enum values from domain.yaml"""
    pass


# Complex Value Objects
@dataclass(frozen=True)
class {ValueObjectName}:
    """
    Immutable Value Object

    Invariants:
        - TODO: Define validation rules
    """
    value: str

    def __post_init__(self):
        # TODO: Add validation
        pass
```

#### events.py

```python
"""
{ContextName} Domain - Domain Events
Generated by /bda-skeleton
"""
from dataclasses import dataclass
from datetime import datetime

from .value_objects import {AggregateName}Id


@dataclass(frozen=True)
class {EventName}:
    """
    Domain Event: {EventDescription}

    Published when: {trigger_condition}
    """
    {aggregate_name}_id: {AggregateName}Id
    occurred_at: datetime

    # TODO: Add properties from domain.yaml events section
```

#### repository.py (Interface)

```python
"""
{ContextName} Domain - Repository Interface
Generated by /bda-skeleton
"""
from abc import ABC, abstractmethod
from typing import Optional, List

from .entity import {AggregateName}
from .value_objects import {AggregateName}Id


class I{AggregateName}Repository(ABC):
    """
    Repository Interface for {AggregateName} Aggregate

    Note:
        Implementation is in infrastructure layer.
        Domain layer only defines the contract.
    """

    @abstractmethod
    async def save(self, entity: {AggregateName}) -> {AggregateName}:
        """Persist the aggregate."""
        raise NotImplementedError()

    @abstractmethod
    async def find_by_id(self, id: {AggregateName}Id) -> Optional[{AggregateName}]:
        """Find aggregate by ID."""
        raise NotImplementedError()

    # TODO: Add methods from domain.yaml repositories section
```

---

### Application Layer

#### {usecase_name}.py

```python
"""
{ContextName} Application - {UseCaseName} UseCase
Generated by /bda-skeleton
"""
from dataclasses import dataclass

from domain.{context}.repository import I{AggregateName}Repository
from domain.{context}.entity import {AggregateName}
from .dto import {AggregateName}DTO


@dataclass
class {UseCaseName}Input:
    """Input DTO for {UseCaseName}"""
    # TODO: Add fields from application.yaml useCases[].input
    pass


@dataclass
class {UseCaseName}Output:
    """Output DTO for {UseCaseName}"""
    # TODO: Define output structure
    pass


class {UseCaseName}UseCase:
    """
    UseCase: {UseCaseName}

    Flow: {flow_description}
    """

    def __init__(
        self,
        repository: I{AggregateName}Repository,
        # TODO: Add other dependencies (event_publisher, etc.)
    ):
        self._repository = repository

    async def execute(self, input: {UseCaseName}Input) -> {UseCaseName}Output:
        """
        Execute the use case.

        Args:
            input: Use case input

        Returns:
            Use case output

        Raises:
            NotFoundError: If entity not found
            ValidationError: If business rule violated
        """
        # TODO: Implement flow from application.yaml
        # Flow: {flow}
        raise NotImplementedError()
```

---

### Infrastructure Layer

#### repository_impl.py

```python
"""
{ContextName} Infrastructure - Repository Implementation
Generated by /bda-skeleton
"""
from typing import Optional, List
from sqlalchemy.ext.asyncio import AsyncSession

from domain.{context}.repository import I{AggregateName}Repository
from domain.{context}.entity import {AggregateName}
from domain.{context}.value_objects import {AggregateName}Id
from .orm_models import {AggregateName}ORM


class {AggregateName}RepositoryImpl(I{AggregateName}Repository):
    """
    SQLAlchemy implementation of {AggregateName}Repository
    """

    def __init__(self, session: AsyncSession):
        self._session = session

    async def save(self, entity: {AggregateName}) -> {AggregateName}:
        """Persist the aggregate."""
        # TODO: Implement ORM mapping and persistence
        raise NotImplementedError()

    async def find_by_id(self, id: {AggregateName}Id) -> Optional[{AggregateName}]:
        """Find aggregate by ID."""
        # TODO: Implement query
        raise NotImplementedError()
```

---

### Interfaces Layer

#### {context}_controller.py (FastAPI)

```python
"""
{ContextName} API - Controller
Generated by /bda-skeleton
"""
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel

from application.{context}.{usecase_name} import (
    {UseCaseName}UseCase,
    {UseCaseName}Input,
)
from .dependencies import get_{context}_repository


router = APIRouter(prefix="/{context}s", tags=["{ContextName}"])


class {UseCaseName}Request(BaseModel):
    """Request body for {UseCaseName}"""
    # TODO: Define request fields
    pass


class {UseCaseName}Response(BaseModel):
    """Response body for {UseCaseName}"""
    # TODO: Define response fields
    pass


@router.post("/", status_code=status.HTTP_201_CREATED)
async def create_{context}(
    request: {UseCaseName}Request,
    repository=Depends(get_{context}_repository),
) -> {UseCaseName}Response:
    """
    Create a new {context}.

    TODO: Add detailed description
    """
    use_case = {UseCaseName}UseCase(repository=repository)

    try:
        result = await use_case.execute(
            {UseCaseName}Input(
                # TODO: Map request to input
            )
        )
        return {UseCaseName}Response(
            # TODO: Map output to response
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
```

---

## 実行フロー

1. Inventoryファイルを読み込む
2. tech_stack.yaml から言語/フレームワークを特定
3. 各Layer のアイテムに対してスケルトンを生成
4. `__init__.py` と依存関係を整理
5. Inventory の Status を `[S]` (Skeleton) に更新

## オプション

| Option | Description |
|--------|-------------|
| `--dry-run` | ファイルを生成せず、プレビューのみ |
| `--force` | 既存ファイルを上書き |
| `--layer {layer}` | 特定レイヤーのみ生成 |
| `--backend-only` | Backend のみ生成 |
| `--frontend-only` | Frontend のみ生成 |

## 生成後の作業

1. `# TODO:` コメントを検索して実装を埋める
2. `/bda-check` で進捗を確認
3. テストを書く（Step 4: Red Phase）
