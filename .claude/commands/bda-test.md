# /bda-test - テストコード自動生成

設計ファイル（application.yaml, domain.yaml）からテストコードを自動生成します。

## 引数

```
/bda-test {context_name}
/bda-test {context_name} --layer {domain|application|integration}
/bda-test {context_name} --usecase {usecase_name}
/bda-test {context_name} --coverage-report
```

## 生成されるテストファイル

```
tests/
├── domain/{context}/
│   ├── test_entity.py          # Aggregate テスト
│   ├── test_value_objects.py   # Value Object テスト
│   └── test_events.py          # Domain Event テスト
├── application/{context}/
│   ├── test_create_{aggregate}.py   # UseCase テスト
│   ├── test_{action}_{aggregate}.py
│   └── test_queries.py              # Query テスト
└── integration/{context}/
    ├── test_{context}_api.py        # API統合テスト
    └── conftest.py                  # Fixtures
```

---

## テスト生成ルール

### 1. Domain Layer テスト

#### Aggregate テスト (test_entity.py)

**入力 (domain.yaml):**
```yaml
aggregates:
  - name: Todo
    behaviors:
      - { name: complete, emits: TodoCompleted, desc: "ステータスを完了にする" }
```

**出力 (test_entity.py):**
```python
"""
Todo Aggregate Tests
Generated by /bda-test from domain.yaml
"""
import pytest
from datetime import datetime

from domain.todo.entity import Todo
from domain.todo.value_objects import TodoId, TodoStatus
from domain.todo.events import TodoCompleted


class TestTodoAggregate:
    """Todo Aggregate のテスト"""

    # === Factory / Constructor Tests ===

    def test_create_todo_with_valid_data(self):
        """正常なデータでTodoを作成できる"""
        # Given
        todo_id = TodoId(1)
        title = "Test Todo"

        # When
        todo = Todo(id=todo_id, title=title, status=TodoStatus.PENDING)

        # Then
        assert todo.id == todo_id
        assert todo.title == title
        assert todo.status == TodoStatus.PENDING

    def test_create_todo_with_empty_title_raises_error(self):
        """空のタイトルでTodo作成時にエラー"""
        # Given
        todo_id = TodoId(1)
        title = ""

        # When / Then
        with pytest.raises(ValueError, match="title cannot be empty"):
            Todo(id=todo_id, title=title, status=TodoStatus.PENDING)

    # === Behavior Tests ===

    class TestComplete:
        """Todo.complete() のテスト"""

        def test_complete_pending_todo_returns_event(self):
            """
            PENDING状態のTodoをcompleteするとTodoCompletedイベントが返る

            Given: PENDING状態のTodo
            When: complete()を呼ぶ
            Then: TodoCompletedイベントが返り、ステータスがCOMPLETEDになる
            """
            # Given
            todo = Todo(
                id=TodoId(1),
                title="Test",
                status=TodoStatus.PENDING
            )

            # When
            event = todo.complete()

            # Then
            assert isinstance(event, TodoCompleted)
            assert event.todo_id == TodoId(1)
            assert todo.status == TodoStatus.COMPLETED

        def test_complete_already_completed_todo_raises_error(self):
            """
            既にCOMPLETED状態のTodoをcompleteするとエラー

            Given: COMPLETED状態のTodo
            When: complete()を呼ぶ
            Then: InvalidOperationErrorが発生
            """
            # Given
            todo = Todo(
                id=TodoId(1),
                title="Test",
                status=TodoStatus.COMPLETED
            )

            # When / Then
            with pytest.raises(InvalidOperationError, match="already completed"):
                todo.complete()


class TestTodoInvariants:
    """Todo Aggregate の不変条件テスト"""

    def test_title_max_length(self):
        """タイトルは200文字以内"""
        with pytest.raises(ValueError):
            Todo(id=TodoId(1), title="x" * 201, status=TodoStatus.PENDING)
```

---

### 2. Application Layer テスト

#### UseCase テスト

**入力 (application.yaml):**
```yaml
useCases:
  - name: CompleteTodo
    input: { todoId: TodoId, userId: UserId }
    output: TodoDTO
    flow: "Repo.find -> Todo.complete() -> Repo.save -> EventPublisher.publish"
```

**出力 (test_complete_todo.py):**
```python
"""
CompleteTodo UseCase Tests
Generated by /bda-test from application.yaml

Flow: Repo.find -> Todo.complete() -> Repo.save -> EventPublisher.publish
"""
import pytest
from unittest.mock import Mock, AsyncMock

from domain.todo.entity import Todo
from domain.todo.value_objects import TodoId, UserId, TodoStatus
from domain.todo.events import TodoCompleted
from application.todo.complete_todo import (
    CompleteTodoUseCase,
    CompleteTodoInput,
)


@pytest.fixture
def mock_repository():
    """Mock TodoRepository"""
    repo = Mock()
    repo.find_by_id = AsyncMock()
    repo.save = AsyncMock()
    return repo


@pytest.fixture
def mock_event_publisher():
    """Mock EventPublisher"""
    publisher = Mock()
    publisher.publish = AsyncMock()
    return publisher


@pytest.fixture
def use_case(mock_repository, mock_event_publisher):
    """CompleteTodoUseCase with mocked dependencies"""
    return CompleteTodoUseCase(
        repository=mock_repository,
        event_publisher=mock_event_publisher,
    )


class TestCompleteTodoUseCase:
    """CompleteTodo UseCase のテスト"""

    # === Happy Path ===

    @pytest.mark.asyncio
    async def test_complete_todo_success(
        self, use_case, mock_repository, mock_event_publisher
    ):
        """
        正常系: Todoを完了できる

        Given: PENDING状態のTodoが存在する
        When: CompleteTodoを実行する
        Then:
          - Todoのステータスが COMPLETED になる
          - TodoCompletedイベントが発行される
          - 更新されたTodoが返る
        """
        # Given
        existing_todo = Todo(
            id=TodoId(1),
            title="Test Todo",
            status=TodoStatus.PENDING,
            owner_id=UserId(100),
        )
        mock_repository.find_by_id.return_value = existing_todo

        input_data = CompleteTodoInput(
            todo_id=TodoId(1),
            user_id=UserId(100),
        )

        # When
        result = await use_case.execute(input_data)

        # Then
        # 1. Repository.find が呼ばれた
        mock_repository.find_by_id.assert_called_once_with(TodoId(1))

        # 2. Repository.save が呼ばれた
        mock_repository.save.assert_called_once()
        saved_todo = mock_repository.save.call_args[0][0]
        assert saved_todo.status == TodoStatus.COMPLETED

        # 3. Event が発行された
        mock_event_publisher.publish.assert_called_once()
        event = mock_event_publisher.publish.call_args[0][0]
        assert isinstance(event, TodoCompleted)
        assert event.todo_id == TodoId(1)

        # 4. 結果が返る
        assert result.id == 1
        assert result.status == "COMPLETED"

    # === Error Cases ===

    @pytest.mark.asyncio
    async def test_complete_todo_not_found(
        self, use_case, mock_repository
    ):
        """
        異常系: Todoが見つからない

        Given: 指定IDのTodoが存在しない
        When: CompleteTodoを実行する
        Then: NotFoundError が発生する
        """
        # Given
        mock_repository.find_by_id.return_value = None

        input_data = CompleteTodoInput(
            todo_id=TodoId(999),
            user_id=UserId(100),
        )

        # When / Then
        with pytest.raises(NotFoundError, match="Todo not found"):
            await use_case.execute(input_data)

    @pytest.mark.asyncio
    async def test_complete_todo_not_owner(
        self, use_case, mock_repository
    ):
        """
        異常系: 他人のTodoを完了しようとする

        Given: 別ユーザーが所有するTodo
        When: CompleteTodoを実行する
        Then: ForbiddenError が発生する
        """
        # Given
        other_users_todo = Todo(
            id=TodoId(1),
            title="Test",
            status=TodoStatus.PENDING,
            owner_id=UserId(999),  # 別ユーザー
        )
        mock_repository.find_by_id.return_value = other_users_todo

        input_data = CompleteTodoInput(
            todo_id=TodoId(1),
            user_id=UserId(100),  # 自分
        )

        # When / Then
        with pytest.raises(ForbiddenError, match="not owner"):
            await use_case.execute(input_data)

    @pytest.mark.asyncio
    async def test_complete_already_completed_todo(
        self, use_case, mock_repository
    ):
        """
        異常系: 既に完了済みのTodoを完了しようとする

        Given: COMPLETED状態のTodo
        When: CompleteTodoを実行する
        Then: InvalidOperationError が発生する
        """
        # Given
        completed_todo = Todo(
            id=TodoId(1),
            title="Test",
            status=TodoStatus.COMPLETED,
            owner_id=UserId(100),
        )
        mock_repository.find_by_id.return_value = completed_todo

        input_data = CompleteTodoInput(
            todo_id=TodoId(1),
            user_id=UserId(100),
        )

        # When / Then
        with pytest.raises(InvalidOperationError):
            await use_case.execute(input_data)
```

---

### 3. Integration テスト

#### API統合テスト

**入力 (todo_controller.yaml):**
```yaml
handlers:
  - name: completeTodo
    method: PUT
    path: "/{id}/complete"
    useCase: CompleteTodo
```

**出力 (test_todo_api.py):**
```python
"""
Todo API Integration Tests
Generated by /bda-test from todo_controller.yaml
"""
import pytest
from httpx import AsyncClient
from fastapi import status

from main import app
from tests.conftest import create_test_user, create_test_todo


@pytest.fixture
async def client():
    """Async test client"""
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac


@pytest.fixture
async def auth_headers(client):
    """認証済みヘッダー"""
    user = await create_test_user()
    token = create_jwt_token(user)
    return {"Authorization": f"Bearer {token}"}


class TestCompleteTodoAPI:
    """PUT /api/todos/{id}/complete のテスト"""

    @pytest.mark.asyncio
    async def test_complete_todo_returns_200(
        self, client, auth_headers
    ):
        """正常系: 200とTodoDTOが返る"""
        # Given
        todo = await create_test_todo(status="PENDING")

        # When
        response = await client.put(
            f"/api/todos/{todo.id}/complete",
            headers=auth_headers,
        )

        # Then
        assert response.status_code == status.HTTP_200_OK
        data = response.json()
        assert data["id"] == todo.id
        assert data["status"] == "COMPLETED"

    @pytest.mark.asyncio
    async def test_complete_todo_not_found_returns_404(
        self, client, auth_headers
    ):
        """異常系: 存在しないTodoで404"""
        # When
        response = await client.put(
            "/api/todos/99999/complete",
            headers=auth_headers,
        )

        # Then
        assert response.status_code == status.HTTP_404_NOT_FOUND

    @pytest.mark.asyncio
    async def test_complete_todo_without_auth_returns_401(
        self, client
    ):
        """異常系: 認証なしで401"""
        # When
        response = await client.put("/api/todos/1/complete")

        # Then
        assert response.status_code == status.HTTP_401_UNAUTHORIZED
```

---

## 実行フロー

1. `application.yaml` を読み込み、UseCase/Query を抽出
2. `domain.yaml` を読み込み、Aggregate/Event を抽出
3. 各アイテムに対してテストテンプレートを適用
4. 既存テストファイルがあれば差分のみ追加（`--force` で上書き）
5. Inventory の Test 列を更新

## オプション

| Option | Description |
|--------|-------------|
| `--layer {layer}` | 特定レイヤーのテストのみ生成 |
| `--usecase {name}` | 特定UseCaseのテストのみ生成 |
| `--force` | 既存テストファイルを上書き |
| `--dry-run` | 生成内容をプレビュー |
| `--coverage-report` | テストカバレッジ状況を表示 |

## テスト命名規則

```
test_{action}_{condition}_{expected_result}

例:
- test_complete_todo_success
- test_complete_todo_not_found_raises_error
- test_create_todo_with_empty_title_raises_validation_error
```

## 生成後の作業

1. `# TODO:` コメントを確認し、必要に応じて調整
2. Edge case のテストを追加
3. `pytest` で Red Phase を確認
4. 実装を行い Green に
